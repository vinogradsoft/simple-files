# Прикладные методы

В этом разделе мы рассмотрим прикладные методы. Всего реализовано четыре основных метода для работы с файловой
системой: `copy()`, `move()`, `writeTo()` и `delete()`.

Примеры с использованием только прикладных методов малоинформативны, потому что они не могут быть использованы без
сформированной объектной модели.

Для демонстрации взаимодействия объектной модели и файловой системы был
создан [проект с примерами](https://github.com/vinogradsoft/example) для всех прикладных методов.

В конце этого раздела описана концепция вымышленного приложения, на которое будем ссылаться при постановке задачи для
примеров в следующих разделах этого руководства. В примерах будет создание консольных команд, приближенных к
реальности, для операций копирования, перемещения, записи и удаления файлов и директорий.

> Чтобы сделать примеры более понятными, в них не включены проверки, которые обычно выполняются в коде. Вместо этого,
> примеры фокусируются на создании модели файловой системы и ее записи на диск.

## Описание методов

### Метод copy

Этот метод служит для копирования объектной модели файловой системы на диск. Процесс копирования проходит так: после
того, как объектная модель готова, метод copy вызывается для корневой директории с указанием пути назначения в качестве
аргумента. После этого все файлы, которые связаны с файловой системой, считываются и записываются в место назначения.
Файлы, не связанные с файловой системой, записывают на диск содержимое, которое вы указываете в своей программе.

Результатом копирования будут созданные файлы и папки на диске. Вся созданная структура на диске будет повторять
расположение файлов и директорий объектной модели. Связи у объектов директорий и файлов модели останутся прежними.

Возможные ошибки процесса копирования обычно связаны с указанием несуществующего пути назначения или отсутствием прав на
запись в целевую директорию, в обоих случаях генерируется исключение `Vinograd\IO\Exception\IOException`.

Пример использования метода [copy()](copying-directories.md).

### Метод move

Метод `move` перемещает файлы и директории на основе объектной модели.

Перемещение выполняется следующим образом: у корневого каталога в объектной модели вызывается метод `move()` с указанием
пути к месту назначения. Затем начинается копирование всех файлов и папок в указанное место. После завершения
копирования исходные файлы и папки удаляются с диска. Удаление с диска касается только тех файлов и директорий, которые
были связаны с объектами в модели.

В результате перемещения в указанном месте создаются новые файлы и папки, а исходные удаляются с диска, если они
присутствуют в объектной модели. Структура в месте назначения повторяет структуру модели. Все объекты директорий и
файлов свяжутся с файловой системой в месте назначения.

Возможные ошибки при перемещении обычно связаны с указанием несуществующего пути к месту назначения или отсутствием
права на запись в указанную директорию. В таких случаях возникает исключение `Vinograd\IO\Exception\IOException`.

Основной ошибкой является отсутствие объекта фала в модели, который существует на диске в одной из перемещаемых
директорий объектной модели. Если файл не был добавлен в объектную модель, система не сможет его удалить, так как будет
считать, что файла не существует. Это приведет к удалению не пустой директории и как следствие сгенерирует
исключение `Vinograd\IO\Exception\IOException`, за тем будет следовать возможная потеря данных.
Рекомендуется проверить наличие всех файлов в объектной модели перед выполнением перемещения.

Пример использования метода [move()](stub.md).

### Метод writeTo

Метод `writeTo()` записывает текущее состояние объектной модели в указанное место, аналогично методу `copy()`, но с
одним отличием: связанные файлы не считываются, а записываются "как есть". Все остальные характеристики этих методов
идентичны.

Пример использования метода [writeTo()](stub.md).

### Метод delete

Метод `delete()` удаляет объектную модель из системы, физически удаляя все связанные файлы и папки.

Процесс удаления очень прост: после создания объектной модели у корневого каталога вызывается метод `delete()`.

В результате вызова этого метода все ссылки на другие объекты в модели становятся недействительными, и объекты файлов и
каталогов становятся непригодными для использования в программе. Физически связанные файлы и каталоги удаляются с диска.

Важно отметить, что если вы хотите удалить каталог со всем его содержимым, вам необходимо добавить в модель все файлы и
подкаталоги, содержащиеся в этом каталоге. Если какие-то элементы будут пропущены, это может вызвать исключение
`Vinograd\IO\Exception\IOException` и привести к частичному удалению содержимого каталога.

Пример использования метода [delete()](stub.md).

## Концепция приложения для примеров

Представьте, что мы создаем приложение, состоящее из модулей, каждый из которых имеет четкую структуру с фиксированными
именами директорий для хранения конфигураций, контроллеров, моделей и представлений. Наша задача - автоматизировать
процесс разработки, написав ряд консольных команд помогающих управлять структурой модулей приложения. Сами модули мы
писать не будем, в примерах мы будем управлять директориями и фалами этих модулей.

### Структура директории

Вымышленное приложение имеет следующую структуру:

```
example/
|
|____private/
     |
     |____packages/
          |
          |____Vendor1/
          |    |
          |    |____ModuleName1/
          |    |    |
          |    |    |____etc/
          |    |    |    |
          |    |    |    |____package.xml
          |    |    |
          |    |    |____Controller/
          |    |    |
          |    |    |____Model/
          |    |    |
          |    |    |____View/
          |    |    |
          |    |    |____composer.json
          |    |
          |    |____ ... Другие модули с такой-же структурой
          |
          |____Vendor2/
               |
               |____ ... такая же структура как и в Vendor1
```

По пути `example/private/packages/` находятся создаваемые модули. Папка `Vendor1/` это название поставщика модуля,
а `ModuleName1/` название модуля. Имена поставщика и модуля указаны в пространствах имен каждого создаваемого класса в
модуле. Пространство имен контролера в модуле может выглядеть так: `namespace Vendor1\ModuleName1\Controller;`.

Директория `etc` обязательная и присутствует в каждом модуле, другие директории находящиеся в модуле должны называться
так, как указано в структуре, однако их может и не быть в модуле при отсутствии необходимости в них.

### Содержимое файлов из структуры

В директориях можно найти два файла: `package.xml` и `composer.json`, которые являются важной частью каждого
модуля и должны обязательно присутствовать. Назначение файла `composer.json` понятно, но что касается
файла `package.xml`, то он хранит метаданные модуля. Он содержит два основных узла `name` и `version`. В
узле `name` хранится имя модуля, а в узле `version` - его версия. Для того чтобы модули были переносимыми, создается
файл `composer.json`. В нем указывается имя модуля и в разделе автозагрузки "psr-4" указывается, где можно найти файлы с
пространством имен модуля.

Содержимое `package.xml`:

```xml
<?xml version="1.0"?>
<packege>
    <name>Vendor1/ModuleName1</name>
    <version>1.0.0</version>
</packege>
```

Содержимое `composer.json`:

```json
{
  "name": ":vendor/:module_name",
  "require": {
    "php": ">=8.0"
  },
  "autoload": {
    "psr-4": {
      "Vendor1\\ModuleName1\\": ""
    }
  }
}
```

[К оглавлению](../../README.md#руководство)