# Общая информация

Структурные и прикладные методы являются двумя основными категориями методов, используемых в этой библиотеке.
Структурные методы подготавливают объектную модель директорий и файлов, определяя структуру и связи между ними.
Прикладные методы, с другой стороны, взаимодействуют с файловой системой и предназначены для переноса модели на диск.

Созданная модель может включать уже существующие в файловой системе директории и файлы, а также те, которые еще не
созданы. По сути, модель - это то, что должно получиться на диске в результате использования прикладных методов,
исключая метод `delete()`, который удаляет с диска созданную объектную модель.

Для построения модели файловой системы в библиотеке присутствует два типа объекта: файл (`Vinograd\SimpleFiles\File`) и
директория (`Vinograd\SimpleFiles\Directory`). Файл в работе с файловой системе отвечает только за себя, другими словами
записывает, копирует, перемещает и удаляет только самого себя. Директория же в работе с файловой системе ответственна не
только за себя, но и за дочерние элементы. Так, например, запустив метод копирования у директории, запустятся методы
копирования у всех дочерних элементов.

В общем случае, объекты, моделирующие файловую систему, имеют два состояния: когда объект не связан и когда объект
связан с файловой системой. Связь с файловой системой определяется наличием пути к файлу/директории в объекте.

В случае, когда объект связан с файловой системой, он имеет два пути:

1. Путь к файлу/директории в файловой системе.
2. Путь, определяющий положение объекта в модели.

Путь связи с файловой системой можно получить методом `getPath()`, а путь в объектной модели методом `getLocalPath()`.
Метод `getPath()` возвращает объект `Compass\Path`, а метод `getLocalPath()` строку пути.

> Объект `Compass\Path` - это объектное представление строки пути к файлу, подробнее можно прочитать о нем в
> документации к библиотеке 
> [vinogradsoft/compass](https://github.com/vinogradsoft/compass#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82-path).

## Варианты создания объектов файлов и директорий

Создание объектов возможно в обоих состояниях. Процесс создания объектов файлов и директорий идентичен.

Чтобы создать объект без связи с файловой системой, нужно использовать оператор `new`. При этом важно понимать, что
нужно указать только имя файла или папки, а не путь к уже существующему файлу. Если вы все-таки попытаетесь указать
путь, система выбросит исключение `LogicException`. Аналогичное исключение будет вызвано и в случае передачи пустой
строки. Чтобы все работало правильно, необходимо указать только имя.

Пример:

```php
// File
$file = new File('myFileName.txt');
// Directory
$directory = new Directory('myDirectoryName');
```

Создание объекта со связью с файловой системой требует использования статического метода `createBinded(string $path)`, в
аргументе которого передается путь к файлу в виде строки.

```php
// File
$file = File::createBinded('/var/www/myFileName.txt');
// Directory
$directory = Directory::createBinded('/var/www');
```

Если файла или директории по переданному пути не существует, будет выброшено
исключение `\Vinograd\IO\Exception\NotFoundException`. По умолчанию файлы и директории использует
класс `\Vinograd\SimpleFiles\DefaultFilesystem` для работы с физической файловой системой, и эта файловая система
является локальной. Можно передавать методу создания как абсолютные пути, так и относительные. Правило
простое - `DefaultFilesystem` внутри себя использует php функцию `realpath(...)`. Все возвраты со значением `false` этой
функцией вызовут исключение (см. документацию [realpath](https://www.php.net/manual/ru/function.realpath.php), в
каких случаях эта функция может вернуть `false`).

## Связь с файловой системой

Связать новый объект с файловой системой можно методом `bindWithFilesystem(string $path)`, который принимает
строку пути в качестве аргумента. Связывание нового объекта с файловой системой может потребоваться, если нужно
выполнить связывание по некоторому условию. Внутренние процессы связывания объектов директории и файла отличаются,
однако оба типа объекта имеют один и тот же метод проверки связанности с файловой системой - метод `isBinded`.
Метод `isBinded` возвращает логическое значение.

### Связывание директорий

```php
$directory = new Directory('root');
$directory->bindWithFilesystem('/var/www');
```

В примере выше директория будет создана в случае ее отсутствия в каталоге `/var/www` и будет иметь путь
источника `/var/www/root`. Если директория уже существует, произойдет то же самое, но без создания
директории.

### Связывание файлов

```php
$file = new File('file.txt');
$file->bindWithFilesystem('/var/www');
```

Файл будет создан в каталоге `/var/www` при условии, что по указанному пути `/var/www/file.txt` он еще не существует.
Если файл уже существует в указанной директории, система просто свяжет его, не перезаписывая. Важно отметить, что при
связывании объекта файловой системы запись данных не происходит. Это делается для того, чтобы впоследствии можно было
прочитать данные из указанного источника.

Путь, с которым связывается объект, должен существовать. Важно то, что имя файла или директории не указывается в конце
пути при связывании.

Вот примеры НЕПРАВИЛЬНОГО использования:

- для директорий - `$directory->bindWithFilesystem('/var/www/root')`
- для файлов - `$file->bindWithFilesystem('/var/www/file.txt')`

> Связывание новых объектов файловой системы не является обязательной операцией. Например, можно копировать,
> перемещать и записывать файлы и директории, которые не связаны с файловой системой.

[К оглавлению](../../README.md#руководство)